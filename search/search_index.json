{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Mean Reversal Research","text":""},{"location":"#conducted-by-stephen-sulimani-and-venn-reddy","title":"Conducted by Stephen Sulimani and Venn Reddy","text":""},{"location":"#under-the-guidance-of-dr-ingrid-maria-hybinette-the-university-of-georgia-and-dr-tucker-balch-emory-university","title":"Under the guidance of Dr. Ingrid Maria Hybinette, The University of Georgia, and Dr. Tucker Balch, Emory University.","text":"<p>This research was highly inspired by Cluster-driven Hierarchical Representation of Large Asset Universes for Optimal Portfolio Construction.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>python main.py</code> - Run a benchmark test (pre-defined).</li> </ul>"},{"location":"#installation","title":"Installation","text":"<ul> <li>[To be Added]</li> </ul>"},{"location":"#usage","title":"Usage","text":"<ul> <li>[To be Added]</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<ul> <li>[To be Added]</li> </ul>"},{"location":"financialcalc/","title":"FinancialCalc","text":""},{"location":"financialcalc/#financialcalc.positions.calculate_position","title":"<code>calculate_position(stock_df, pos_type)</code>","text":"<p>Calculate the return of a position based on the provided stock DataFrame and position type.</p> <p>This function computes the position's return and returns it as a float.</p> <p>Parameters:</p> Name Type Description Default <code>stock_df</code> <code>DataFrame</code> <p>A DataFrame containing the stock's historical price data.</p> required <code>pos_type</code> <code>str</code> <p>The type of position to calculate (e.g., long, short).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated return of the position.</p> Source code in <code>financialcalc\\positions.py</code> <pre><code>def calculate_position(stock_df: pd.DataFrame, pos_type: PositionType) -&gt; float:\n    \"\"\"Calculate the return of a position based on the provided stock DataFrame and position type.\n\n    This function computes the position's return and returns it as a float.\n\n    Args:\n        stock_df (pd.DataFrame): A DataFrame containing the stock's historical price data.\n        pos_type (str): The type of position to calculate (e.g., long, short).\n\n    Returns:\n        float: The calculated return of the position.\n    \"\"\"\n\n    first_day = stock_df[\"Open\"].iloc[0]\n    last_day = stock_df[\"Close\"].iloc[-1]\n\n    if pos_type == PositionType.LONG:\n        return ((last_day - first_day) / first_day) * 100\n\n    if pos_type == PositionType.SHORT:\n        return ((first_day - last_day) / first_day) * 100\n\n    return -999.99\n</code></pre>"},{"location":"financialcalc/#financialcalc.positions.calculate_position_daily","title":"<code>calculate_position_daily(value, stock_df, pos_type)</code>","text":"<p>Calculate the position's performance based on the provided stock DataFrame and position type.</p> <p>This function computes the daily position value and returns a pd.Series indexed by date that reflects the performance of the position.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The starting capital for the position.</p> required <code>stock_df</code> <code>DataFrame</code> <p>A DataFrame containing the stock's historical price data.</p> required <code>pos_type</code> <code>str</code> <p>The type of position to calculate (e.g., long, short).</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series representing the position's value for each day, indexed by date.</p> Source code in <code>financialcalc\\positions.py</code> <pre><code>def calculate_position_daily(\n    value: float, stock_df: pd.DataFrame, pos_type: PositionType\n) -&gt; pd.Series:\n    \"\"\"Calculate the position's performance based on the provided stock DataFrame and position type.\n\n    This function computes the daily position value and returns a pd.Series indexed by date that reflects the performance of the position.\n\n    Args:\n        value (float): The starting capital for the position.\n        stock_df (pd.DataFrame): A DataFrame containing the stock's historical price data.\n        pos_type (str): The type of position to calculate (e.g., long, short).\n\n    Returns:\n        pd.Series: A Series representing the position's value for each day, indexed by date.\n    \"\"\"\n\n    position_value = pd.Series(index=stock_df.index)\n    position_value.iloc[0] = value\n\n    stock_original_price = stock_df[\"Open\"].iloc[0]\n\n    if pos_type == PositionType.LONG:\n        for i in range(1, len(stock_df)):\n            # Calculate the portfolio value each day, WITHOUT compounding.\n            position_value.iloc[i] = value * (\n                stock_df[\"Close\"].iloc[i] / stock_original_price\n            )\n\n    if pos_type == PositionType.SHORT:\n        for i in range(1, len(stock_df)):\n            # Calculate the portfolio value each day, WITHOUT compounding.\n            position_value.iloc[i] = value * (\n                stock_original_price / stock_df[\"Close\"].iloc[i]\n            )\n\n    return position_value\n</code></pre>"},{"location":"helpers/","title":"Helpers","text":""},{"location":"helpers/#helpers.dates.get_row_by_date","title":"<code>get_row_by_date(df, target_date)</code>","text":"<p>gets the row by date</p> Source code in <code>helpers\\dates.py</code> <pre><code>def get_row_by_date(df, target_date):\n    \"\"\"gets the row by date\"\"\"\n    target_date = pd.to_datetime(target_date)\n\n    if target_date in df.index:\n        return df.loc[target_date]\n    else:\n        # Get the most recent date before the target date\n        recent_date = df.index[df.index &lt; target_date].max()\n        if pd.isna(recent_date):\n            return None  # No valid date found\n        return df.loc[recent_date]\n</code></pre>"},{"location":"helpers/#helpers.graphing.df_to_close_series","title":"<code>df_to_close_series(df)</code>","text":"<p>Converts a DataFrame to a date-indexed Series containing only the 'Close' values. :param df: DataFrame that contains at least 'Date' and 'Close' columns. :return: A series with dates as the index and 'Close' values.</p> Source code in <code>helpers\\graphing.py</code> <pre><code>def df_to_close_series(df):\n    \"\"\"\n    Converts a DataFrame to a date-indexed Series containing only the 'Close' values.\n    :param df: DataFrame that contains at least 'Date' and 'Close' columns.\n    :return: A series with dates as the index and 'Close' values.\n    \"\"\"\n\n    # Ensure a copy is made so the original DataFrame isn't modified\n    df_copy = df.copy()\n\n    # Set 'Date' as the index\n    df_copy.set_index('Date', inplace=True)\n\n    # Return the 'Close' column as a Series\n    close_series = df_copy['Close']\n    return close_series\n</code></pre>"},{"location":"helpers/#helpers.graphing.import_and_filter_csv","title":"<code>import_and_filter_csv(path_to_csv)</code>","text":"<p>Imports a CSV file and filters the data for specific dates. (Not deprecated, but being updated to include filtered data ranges as parameters) :param path_to_csv: The path to the CSV file :return: filtered_df: A DataFrame containing only the data within the specified date range.</p> Source code in <code>helpers\\graphing.py</code> <pre><code>def import_and_filter_csv(path_to_csv):\n    \"\"\"\n    Imports a CSV file and filters the data for specific dates.\n    (Not deprecated, but being updated to include filtered data ranges as parameters)\n    :param path_to_csv: The path to the CSV file\n    :return: filtered_df: A DataFrame containing only the data within the specified date range.\n    \"\"\"\n\n    # Read the CSV file and parse the \"Date\" column as datetime\n    df = pd.read_csv(path_to_csv, parse_dates=[\"Date\"])\n\n    # Define the start and end dates\n    start_date = pd.to_datetime(\"2020-01-02\")\n    end_date = pd.to_datetime(\"2023-12-1\")\n\n    # Filter the DataFrame for dates within the specified range\n    mask = (df[\"Date\"] &gt;= start_date) &amp; (df[\"Date\"] &lt;= end_date)\n    filtered_df = df.loc[mask].reset_index(drop=True)\n\n    # print(\"THIS IS WHAT FILTERED_DF LOOKS LIKE RIGHT NOW!!!!\")\n    # print(filtered_df)\n\n    # print(\"Multiplication Scale to have 1000000 in SPY on day 1:\")\n    to_multiply = 1000000 / filtered_df['Close'][0]\n    # print(to_multiply)\n\n    # print(\"After Normalization:\")\n    filtered_df['Close'] = to_multiply * filtered_df['Close']\n    # print(filtered_df.to_string(float_format=lambda x: f'{x:.2f}'))\n\n    return filtered_df\n</code></pre>"},{"location":"helpers/#helpers.graphing.pretty_line_chart","title":"<code>pretty_line_chart(series_one, series_two, *args)</code>","text":"<p>Graphs two series against each other on the same timeframe. Can also graph variable number of other series over the same timeframe if desired. :param series_one: The first series to be graphed :param series_two: The second series to be graphed :param args: Variable number of series to be graphed :return: None</p> Source code in <code>helpers\\graphing.py</code> <pre><code>def pretty_line_chart(series_one, series_two, *args):\n    \"\"\"\n    Graphs two series against each other on the same timeframe. Can also graph variable number of other\n    series over the same timeframe if desired.\n    :param series_one: The first series to be graphed\n    :param series_two: The second series to be graphed\n    :param args: Variable number of series to be graphed\n    :return: None\n    \"\"\"\n    plt.figure(figsize=(16,10), dpi=80)\n    plt.plot(series_one.index, series_one.values, color='tab:red', label=\"Mean Reversal Portfolio\")\n    plt.plot(series_two.index, series_two.values, color='blue', label = \"SPY\")  # New line to plot series_two in blue\n\n    # For plotting variable random tests\n    random_rgb = lambda: (random.random(), random.random(), random.random())\n    i = 1\n    for arg in args:\n        to_label = f\"Random Portfolio {i}\"\n        plt.plot(series_one.index, arg.values, color=random_rgb(), label=to_label)\n        i += 1\n\n    # Decoration: adjust the y-limits as needed\n    global_min = min(series_one.min(), series_two.min())\n    global_max = max(series_one.max(), series_two.max())\n    plt.ylim(global_min * 0.90, global_max * 1.10)\n\n    # Create xtick locations from the index (every 12th date)\n    xtick_locations = series_one.index[::12]\n\n    # Set the x-axis to use one tick per month\n    ax = plt.gca()\n    ax.xaxis.set_major_locator(mdates.MonthLocator(interval=3))\n    ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %Y'))  # Use '%b' for abbreviated month name\n\n    plt.title(\"Comparison of Mean Reversal Portfolio to SPY\", fontsize=22)\n    plt.grid(axis='both', alpha=0.3)\n\n    # Remove borders\n    ax.spines[\"top\"].set_alpha(0.0)\n    ax.spines[\"bottom\"].set_alpha(0.3)\n    ax.spines[\"right\"].set_alpha(0.0)\n    ax.spines[\"left\"].set_alpha(0.3)\n\n    plt.legend(loc=\"upper left\", fontsize=16)\n    plt.show()\n</code></pre>"},{"location":"macrotrends/","title":"MacroTrends","text":""},{"location":"macrotrends/#macrotrends.macrotrends.MacroTrends","title":"<code>MacroTrends</code>","text":"Source code in <code>macrotrends\\macrotrends.py</code> <pre><code>class MacroTrends:\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def download(\n        ticker: str, start_date=\"00-00-00\", end_date=\"00-00-00\"\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Downloads stock data for a given ticker from MacroTrends.\n\n        Args:\n            start_date (str): The start date of the data to download, formatted as YYYY-MM-DD.\n                Defaults to the stock's inception.\n            end_date (str): The end date of the data to download, formatted as YYYY-MM-DD.\n                Defaults to the most recent available date.\n            ticker (str): The stock ticker to download data for.\n\n        Returns:\n            Any: Description of the returned value.\n        \"\"\"\n\n        headers = {\n            \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36\",\n            \"Referer\": f\"https://www.macrotrends.net/assets/php/stock_price_history.php?t={ticker}\",\n        }\n\n        resp = requests.get(\n            f\"https://www.macrotrends.net/assets/php/stock_data_download.php?t={ticker}\",\n            headers=headers,\n        )\n\n        if resp.status_code != 200:\n            raise Exception(\"Failed to download stock data\")\n            resp.raise_for_status()\n\n        lines = resp.text.split(\"\\n\")\n\n        cleaned_lines = lines[15:]\n\n        df = pd.DataFrame(\n            [line.split(\",\") for line in cleaned_lines],\n            columns=[\"Date\", \"Open\", \"High\", \"Low\", \"Close\", \"Volume\"],\n        )\n        df = df.set_index(\"Date\")\n\n        df.index = pd.to_datetime(df.index, format=\"%Y-%m-%d\")\n\n        df = df.dropna(how=\"any\")\n\n        if start_date != \"00-00-00\":\n            start_date = datetime.strptime(start_date, \"%Y-%m-%d\")\n            df = df[df.index &gt;= start_date]\n\n        if end_date != \"00-00-00\":\n            end_date = datetime.strptime(end_date, \"%Y-%m-%d\")\n            df = df[df.index &lt;= end_date]\n\n        return df\n</code></pre>"},{"location":"macrotrends/#macrotrends.macrotrends.MacroTrends.download","title":"<code>download(ticker, start_date='00-00-00', end_date='00-00-00')</code>  <code>staticmethod</code>","text":"<p>Downloads stock data for a given ticker from MacroTrends.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>The start date of the data to download, formatted as YYYY-MM-DD. Defaults to the stock's inception.</p> <code>'00-00-00'</code> <code>end_date</code> <code>str</code> <p>The end date of the data to download, formatted as YYYY-MM-DD. Defaults to the most recent available date.</p> <code>'00-00-00'</code> <code>ticker</code> <code>str</code> <p>The stock ticker to download data for.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>DataFrame</code> <p>Description of the returned value.</p> Source code in <code>macrotrends\\macrotrends.py</code> <pre><code>@staticmethod\ndef download(\n    ticker: str, start_date=\"00-00-00\", end_date=\"00-00-00\"\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Downloads stock data for a given ticker from MacroTrends.\n\n    Args:\n        start_date (str): The start date of the data to download, formatted as YYYY-MM-DD.\n            Defaults to the stock's inception.\n        end_date (str): The end date of the data to download, formatted as YYYY-MM-DD.\n            Defaults to the most recent available date.\n        ticker (str): The stock ticker to download data for.\n\n    Returns:\n        Any: Description of the returned value.\n    \"\"\"\n\n    headers = {\n        \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36\",\n        \"Referer\": f\"https://www.macrotrends.net/assets/php/stock_price_history.php?t={ticker}\",\n    }\n\n    resp = requests.get(\n        f\"https://www.macrotrends.net/assets/php/stock_data_download.php?t={ticker}\",\n        headers=headers,\n    )\n\n    if resp.status_code != 200:\n        raise Exception(\"Failed to download stock data\")\n        resp.raise_for_status()\n\n    lines = resp.text.split(\"\\n\")\n\n    cleaned_lines = lines[15:]\n\n    df = pd.DataFrame(\n        [line.split(\",\") for line in cleaned_lines],\n        columns=[\"Date\", \"Open\", \"High\", \"Low\", \"Close\", \"Volume\"],\n    )\n    df = df.set_index(\"Date\")\n\n    df.index = pd.to_datetime(df.index, format=\"%Y-%m-%d\")\n\n    df = df.dropna(how=\"any\")\n\n    if start_date != \"00-00-00\":\n        start_date = datetime.strptime(start_date, \"%Y-%m-%d\")\n        df = df[df.index &gt;= start_date]\n\n    if end_date != \"00-00-00\":\n        end_date = datetime.strptime(end_date, \"%Y-%m-%d\")\n        df = df[df.index &lt;= end_date]\n\n    return df\n</code></pre>"},{"location":"sector/","title":"Sector","text":""},{"location":"sector/#sector.definitions.sp500_sectors","title":"<code>sp500_sectors()</code>","text":"<p>This function scrapes the S&amp;P 500 stocks from the Wikipedia page and creates a dict mapping each sector to a list of stock tickers.</p> <p>Returns:</p> Type Description <code>Dict[str, List[str]] | Literal[False]</code> <p>pd.DataFrame or Literal[False]: A dict organizing all of the S&amp;P 500 stocks, or False if the request fails.</p> Source code in <code>sector\\definitions.py</code> <pre><code>def sp500_sectors() -&gt; Dict[str, List[str]] | Literal[False]:\n    \"\"\"\n    This function scrapes the S&amp;P 500 stocks from the Wikipedia page and creates a dict mapping each sector to a list of stock tickers.\n\n    Returns:\n        pd.DataFrame or Literal[False]: A dict organizing all of the S&amp;P 500 stocks, or False if the request fails.\n    \"\"\"\n    wikipedia_sp500_url = \"https://en.wikipedia.org/wiki/List_of_S%26P_500_companies\"\n\n    resp = requests.get(wikipedia_sp500_url)\n\n    if resp.status_code != 200:\n        return False\n\n    matches = re.finditer(\n        r'&lt;a\\srel=\"nofollow\"\\sclass=\"external\\stext\"\\shref=\".*?\"&gt;(\\w+)&lt;\\/a&gt;\\s+&lt;\\/td&gt;\\s+&lt;td&gt;.*?&gt;(.*?)&lt;.*\\s&lt;td&gt;(.*?)&lt;',\n        resp.text,\n    )\n\n    sector_dict: Dict[str, List[str]] = {}\n\n    for match in matches:\n        if match is None:\n            continue\n        if match.group(3) in sector_dict:\n            sector_dict[match.group(3)].append(match.group(1))\n        else:\n            sector_dict[match.group(3)] = [match.group(1)]\n\n    return sector_dict\n</code></pre>"},{"location":"sector/#sector.sector.Sector","title":"<code>Sector</code>","text":"Source code in <code>sector\\sector.py</code> <pre><code>class Sector:\n    sector_name: str\n    sector_stocks: List[str] = []\n    start_date: datetime\n    midpoint_date: datetime\n    end_date: datetime\n\n    best_stock: str = \"\"\n    best_stock_df: pd.DataFrame\n    best_stock_performance: float\n\n    worst_stock: str = \"\"\n    worst_stock_df: pd.DataFrame\n    worst_stock_performance: float\n\n    short_performance: float\n    long_performance: float\n\n    def __init__(self, sector_name: str, sector_stocks: List[str]):\n        \"\"\"\n        Constructor for the Session class.\n\n        Args:\n            sector_name (str): The name of the sector.\n            sector_stocks (list[str]): The stock tickers contained within the sector.\n        \"\"\"\n        # Define Sector Properties\n        self.sector_name = sector_name\n        self.sector_stocks = sector_stocks\n\n    def set_dates(self, start_date: str, midpoint_date: str, end_date: str):\n        \"\"\"\n        The function to set the start, midpoint, and end dates.\n\n        Args:\n            start_date (str): The date to begin the analysis. Format: %Y-%m-%d.\n            midpoint_date (str): The date to end the analysis and open the position. Format: %Y-%m-%d.\n            end_date (str): The date to close the position. Format: %Y-%m-%d.\n        \"\"\"\n        # Parse Datetime Strings\n        self.start_date = datetime.strptime(start_date, \"%Y-%m-%d\")\n        self.midpoint_date = datetime.strptime(midpoint_date, \"%Y-%m-%d\")\n        self.end_date = datetime.strptime(end_date, \"%Y-%m-%d\")\n\n    @staticmethod\n    def load_stock(stock_ticker: str) -&gt; pd.DataFrame:\n        \"\"\"\n        Loads and returns a stock's dataframe.\n\n        Args:\n            stock_ticker (str): The ticker of the stock.\n\n        Returns:\n            pd.DataFrame: The DataFrame representing the stock's historical price.\n        \"\"\"\n        # Change In Production!!\n        if stock_ticker.endswith(\".1\"):\n            stock_ticker = stock_ticker[:-2]\n        if os.path.exists(f\"data/{stock_ticker}.csv\"):\n            df = pd.read_csv(f\"data/{stock_ticker}.csv\")\n            df = df.set_index(\"Date\")\n            df.index = pd.to_datetime(df.index)\n        else:\n            print(f\"Downloading Stock Data for {stock_ticker}\")\n            df = MacroTrends.download(stock_ticker)\n            df.to_csv(f\"data/{stock_ticker}.csv\")\n        return df\n\n    def calculate_best_worst(self):\n        \"\"\"Calculates the best performing and worst performing stocks in the sector. \"\"\"\n        for ticker in self.sector_stocks:\n            try:\n                original_df = self.load_stock(ticker)\n\n                df = original_df.loc[self.start_date : self.midpoint_date].iloc[:-1]\n                initial_price = df[\"Open\"].iloc[0]\n                final_price = df[\"Close\"].iloc[-1]\n\n                performance = (final_price - initial_price) / initial_price * 100\n\n                if self.best_stock == \"\" or performance &gt; self.best_stock_performance:\n                    self.best_stock = ticker\n                    self.best_stock_df = original_df\n                    self.best_stock_performance = performance\n\n                if self.worst_stock == \"\" or performance &lt; self.worst_stock_performance:\n                    self.worst_stock = ticker\n                    self.worst_stock_df = original_df\n                    self.worst_stock_performance = performance\n            except:\n                # In case the ticker doesn't have sufficient data, it will\n                # be automatically excluded.\n                pass\n\n    def test_best_worst(self):\n        \"\"\"Calculate the performance of the SHORT and LONG positions,\n        for the best and worst stocks in a sector, respectively.\n        \"\"\"\n        best_df = self.best_stock_df.loc[self.midpoint_date : self.end_date]\n        worst_df = self.worst_stock_df.loc[self.midpoint_date : self.end_date]\n\n        self.short_performance = calculate_position(best_df, PositionType.SHORT)\n        self.long_performance = calculate_position(worst_df, PositionType.LONG)\n\n    def run_calculations(self, start_date: str, midpoint_date: str, end_date: str):\n        \"\"\"\n        The master function for the Sector class that runs all calculations needed to determine the best and worst stocks in a sector, and then tests the mean reversion strategy by opening a SHORT and LONG position for the best and worst stocks, respectively. Finally, the returns are calculated for the two positions and printed to the console and graphed.\n\n        Args:\n            start_date (str): The date to begin the analysis. Format: %Y-%m-%d.\n            midpoint_date (str): The date to end the analysis and open the position. Format: %Y-%m-%d.\n            end_date (str): The date to close the position. Format: %Y-%m-%d.\n        \"\"\"\n\n        self.set_dates(start_date, midpoint_date, end_date)\n        self.calculate_best_worst()\n        self.test_best_worst()\n\n    def graph_sectors(self):\n        \"\"\"\n        Graphs the best and worst stocks in a sector between given date ranges, with the short of the best\n        stock and long of the worst stock shown after the midpoint.\n        \"\"\"\n        best_df = self.best_stock_df.loc[self.start_date : self.end_date].copy()\n        worst_df = self.worst_stock_df.loc[self.start_date : self.end_date].copy()\n\n        # Plotting the cumulative return of the best performing stock in the sector\n        initial_close = best_df[\"Close\"].iloc[0]\n        best_df[\"Cum_Return\"] = (\n            (best_df[\"Close\"] - initial_close) / initial_close\n        ) * 100\n\n        best_df_first = best_df.loc[: self.midpoint_date]\n        best_df_second = best_df.loc[self.midpoint_date :]\n\n        plt.plot(\n            best_df_first.index,\n            best_df_first[\"Cum_Return\"],\n            label=f\"{self.best_stock} (Best)\",\n            color=\"blue\",\n        )\n        plt.plot(\n            best_df_second.index,\n            best_df_second[\"Cum_Return\"],\n            linestyle=\"dashed\",\n            color=\"blue\",\n            label=f\"{self.best_stock} (Backtesting) | Position Return: {self.short_performance:.2f}%\",\n        )\n\n        # Plotting the cumulative return of the worst performing stock in the sector\n        initial_close = worst_df[\"Close\"].iloc[0]\n        worst_df[\"Cum_Return\"] = (\n            (worst_df[\"Close\"] - initial_close) / initial_close\n        ) * 100\n\n        worst_df_first = worst_df.loc[: self.midpoint_date]\n        worst_df_second = worst_df.loc[self.midpoint_date :]\n\n        plt.plot(\n            worst_df_first.index,\n            worst_df_first[\"Cum_Return\"],\n            label=f\"{self.worst_stock} (Worst)\",\n            color=\"red\",\n        )\n        plt.plot(\n            worst_df_second.index,\n            worst_df_second[\"Cum_Return\"],\n            linestyle=\"dashed\",\n            color=\"red\",\n            label=f\"{self.worst_stock} (Backtesting) | Position Return: {self.long_performance:.2f}%\",\n        )\n\n        # Collecting absolute values of all the max &amp; min returns to find the largest in either direction\n        best_max, best_min = (best_df[\"Cum_Return\"].max(), best_df[\"Cum_Return\"].min())\n        worst_max, worst_min = (\n            worst_df[\"Cum_Return\"].max(),\n            worst_df[\"Cum_Return\"].min(),\n        )\n        all_extrema = [abs(best_max), abs(best_min), abs(worst_max), abs(worst_min)]\n\n        # Setting the y-limit to the highest extrema + a 10% buffer:\n        y_lim = max(all_extrema)\n        buffer = 0.1 * y_lim\n        plt.ylim(-y_lim - buffer, y_lim + buffer)\n\n        # Drawing vertical dashed line at midpoint\n        plt.axvline(\n            mdates.date2num(self.midpoint_date),\n            color=\"black\",\n            linestyle=\"dashed\",\n            linewidth=2,\n            label=\"Start of Backtest\",\n        )\n\n        # Labeling and setting up my plot\n        plt.title(f\"{self.sector_name}: Best and Worst Stocks Compared\")\n        plt.xlabel(\"Date\")\n        plt.ylabel(\"Stock Return (%)\")\n        plt.legend()\n        plt.grid(True)\n\n        # Saving the plot onto local storage (I .gitignored ./graphs but we can test non-local storage in future)\n        image_directory = \"./graphs\"\n        os.makedirs(image_directory, exist_ok=True)\n        image_path = f\"{image_directory}/{self.sector_name}.png\"\n        plt.savefig(image_path)\n        plt.close()\n\n        print(\n            f\"Graphed and saved stock comparison of {self.best_stock} vs {self.worst_stock}. in {image_path}\"\n        )\n</code></pre>"},{"location":"sector/#sector.sector.Sector.__init__","title":"<code>__init__(sector_name, sector_stocks)</code>","text":"<p>Constructor for the Session class.</p> <p>Parameters:</p> Name Type Description Default <code>sector_name</code> <code>str</code> <p>The name of the sector.</p> required <code>sector_stocks</code> <code>list[str]</code> <p>The stock tickers contained within the sector.</p> required Source code in <code>sector\\sector.py</code> <pre><code>def __init__(self, sector_name: str, sector_stocks: List[str]):\n    \"\"\"\n    Constructor for the Session class.\n\n    Args:\n        sector_name (str): The name of the sector.\n        sector_stocks (list[str]): The stock tickers contained within the sector.\n    \"\"\"\n    # Define Sector Properties\n    self.sector_name = sector_name\n    self.sector_stocks = sector_stocks\n</code></pre>"},{"location":"sector/#sector.sector.Sector.calculate_best_worst","title":"<code>calculate_best_worst()</code>","text":"<p>Calculates the best performing and worst performing stocks in the sector.</p> Source code in <code>sector\\sector.py</code> <pre><code>def calculate_best_worst(self):\n    \"\"\"Calculates the best performing and worst performing stocks in the sector. \"\"\"\n    for ticker in self.sector_stocks:\n        try:\n            original_df = self.load_stock(ticker)\n\n            df = original_df.loc[self.start_date : self.midpoint_date].iloc[:-1]\n            initial_price = df[\"Open\"].iloc[0]\n            final_price = df[\"Close\"].iloc[-1]\n\n            performance = (final_price - initial_price) / initial_price * 100\n\n            if self.best_stock == \"\" or performance &gt; self.best_stock_performance:\n                self.best_stock = ticker\n                self.best_stock_df = original_df\n                self.best_stock_performance = performance\n\n            if self.worst_stock == \"\" or performance &lt; self.worst_stock_performance:\n                self.worst_stock = ticker\n                self.worst_stock_df = original_df\n                self.worst_stock_performance = performance\n        except:\n            # In case the ticker doesn't have sufficient data, it will\n            # be automatically excluded.\n            pass\n</code></pre>"},{"location":"sector/#sector.sector.Sector.graph_sectors","title":"<code>graph_sectors()</code>","text":"<p>Graphs the best and worst stocks in a sector between given date ranges, with the short of the best stock and long of the worst stock shown after the midpoint.</p> Source code in <code>sector\\sector.py</code> <pre><code>def graph_sectors(self):\n    \"\"\"\n    Graphs the best and worst stocks in a sector between given date ranges, with the short of the best\n    stock and long of the worst stock shown after the midpoint.\n    \"\"\"\n    best_df = self.best_stock_df.loc[self.start_date : self.end_date].copy()\n    worst_df = self.worst_stock_df.loc[self.start_date : self.end_date].copy()\n\n    # Plotting the cumulative return of the best performing stock in the sector\n    initial_close = best_df[\"Close\"].iloc[0]\n    best_df[\"Cum_Return\"] = (\n        (best_df[\"Close\"] - initial_close) / initial_close\n    ) * 100\n\n    best_df_first = best_df.loc[: self.midpoint_date]\n    best_df_second = best_df.loc[self.midpoint_date :]\n\n    plt.plot(\n        best_df_first.index,\n        best_df_first[\"Cum_Return\"],\n        label=f\"{self.best_stock} (Best)\",\n        color=\"blue\",\n    )\n    plt.plot(\n        best_df_second.index,\n        best_df_second[\"Cum_Return\"],\n        linestyle=\"dashed\",\n        color=\"blue\",\n        label=f\"{self.best_stock} (Backtesting) | Position Return: {self.short_performance:.2f}%\",\n    )\n\n    # Plotting the cumulative return of the worst performing stock in the sector\n    initial_close = worst_df[\"Close\"].iloc[0]\n    worst_df[\"Cum_Return\"] = (\n        (worst_df[\"Close\"] - initial_close) / initial_close\n    ) * 100\n\n    worst_df_first = worst_df.loc[: self.midpoint_date]\n    worst_df_second = worst_df.loc[self.midpoint_date :]\n\n    plt.plot(\n        worst_df_first.index,\n        worst_df_first[\"Cum_Return\"],\n        label=f\"{self.worst_stock} (Worst)\",\n        color=\"red\",\n    )\n    plt.plot(\n        worst_df_second.index,\n        worst_df_second[\"Cum_Return\"],\n        linestyle=\"dashed\",\n        color=\"red\",\n        label=f\"{self.worst_stock} (Backtesting) | Position Return: {self.long_performance:.2f}%\",\n    )\n\n    # Collecting absolute values of all the max &amp; min returns to find the largest in either direction\n    best_max, best_min = (best_df[\"Cum_Return\"].max(), best_df[\"Cum_Return\"].min())\n    worst_max, worst_min = (\n        worst_df[\"Cum_Return\"].max(),\n        worst_df[\"Cum_Return\"].min(),\n    )\n    all_extrema = [abs(best_max), abs(best_min), abs(worst_max), abs(worst_min)]\n\n    # Setting the y-limit to the highest extrema + a 10% buffer:\n    y_lim = max(all_extrema)\n    buffer = 0.1 * y_lim\n    plt.ylim(-y_lim - buffer, y_lim + buffer)\n\n    # Drawing vertical dashed line at midpoint\n    plt.axvline(\n        mdates.date2num(self.midpoint_date),\n        color=\"black\",\n        linestyle=\"dashed\",\n        linewidth=2,\n        label=\"Start of Backtest\",\n    )\n\n    # Labeling and setting up my plot\n    plt.title(f\"{self.sector_name}: Best and Worst Stocks Compared\")\n    plt.xlabel(\"Date\")\n    plt.ylabel(\"Stock Return (%)\")\n    plt.legend()\n    plt.grid(True)\n\n    # Saving the plot onto local storage (I .gitignored ./graphs but we can test non-local storage in future)\n    image_directory = \"./graphs\"\n    os.makedirs(image_directory, exist_ok=True)\n    image_path = f\"{image_directory}/{self.sector_name}.png\"\n    plt.savefig(image_path)\n    plt.close()\n\n    print(\n        f\"Graphed and saved stock comparison of {self.best_stock} vs {self.worst_stock}. in {image_path}\"\n    )\n</code></pre>"},{"location":"sector/#sector.sector.Sector.load_stock","title":"<code>load_stock(stock_ticker)</code>  <code>staticmethod</code>","text":"<p>Loads and returns a stock's dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>stock_ticker</code> <code>str</code> <p>The ticker of the stock.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: The DataFrame representing the stock's historical price.</p> Source code in <code>sector\\sector.py</code> <pre><code>@staticmethod\ndef load_stock(stock_ticker: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Loads and returns a stock's dataframe.\n\n    Args:\n        stock_ticker (str): The ticker of the stock.\n\n    Returns:\n        pd.DataFrame: The DataFrame representing the stock's historical price.\n    \"\"\"\n    # Change In Production!!\n    if stock_ticker.endswith(\".1\"):\n        stock_ticker = stock_ticker[:-2]\n    if os.path.exists(f\"data/{stock_ticker}.csv\"):\n        df = pd.read_csv(f\"data/{stock_ticker}.csv\")\n        df = df.set_index(\"Date\")\n        df.index = pd.to_datetime(df.index)\n    else:\n        print(f\"Downloading Stock Data for {stock_ticker}\")\n        df = MacroTrends.download(stock_ticker)\n        df.to_csv(f\"data/{stock_ticker}.csv\")\n    return df\n</code></pre>"},{"location":"sector/#sector.sector.Sector.run_calculations","title":"<code>run_calculations(start_date, midpoint_date, end_date)</code>","text":"<p>The master function for the Sector class that runs all calculations needed to determine the best and worst stocks in a sector, and then tests the mean reversion strategy by opening a SHORT and LONG position for the best and worst stocks, respectively. Finally, the returns are calculated for the two positions and printed to the console and graphed.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>The date to begin the analysis. Format: %Y-%m-%d.</p> required <code>midpoint_date</code> <code>str</code> <p>The date to end the analysis and open the position. Format: %Y-%m-%d.</p> required <code>end_date</code> <code>str</code> <p>The date to close the position. Format: %Y-%m-%d.</p> required Source code in <code>sector\\sector.py</code> <pre><code>def run_calculations(self, start_date: str, midpoint_date: str, end_date: str):\n    \"\"\"\n    The master function for the Sector class that runs all calculations needed to determine the best and worst stocks in a sector, and then tests the mean reversion strategy by opening a SHORT and LONG position for the best and worst stocks, respectively. Finally, the returns are calculated for the two positions and printed to the console and graphed.\n\n    Args:\n        start_date (str): The date to begin the analysis. Format: %Y-%m-%d.\n        midpoint_date (str): The date to end the analysis and open the position. Format: %Y-%m-%d.\n        end_date (str): The date to close the position. Format: %Y-%m-%d.\n    \"\"\"\n\n    self.set_dates(start_date, midpoint_date, end_date)\n    self.calculate_best_worst()\n    self.test_best_worst()\n</code></pre>"},{"location":"sector/#sector.sector.Sector.set_dates","title":"<code>set_dates(start_date, midpoint_date, end_date)</code>","text":"<p>The function to set the start, midpoint, and end dates.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>The date to begin the analysis. Format: %Y-%m-%d.</p> required <code>midpoint_date</code> <code>str</code> <p>The date to end the analysis and open the position. Format: %Y-%m-%d.</p> required <code>end_date</code> <code>str</code> <p>The date to close the position. Format: %Y-%m-%d.</p> required Source code in <code>sector\\sector.py</code> <pre><code>def set_dates(self, start_date: str, midpoint_date: str, end_date: str):\n    \"\"\"\n    The function to set the start, midpoint, and end dates.\n\n    Args:\n        start_date (str): The date to begin the analysis. Format: %Y-%m-%d.\n        midpoint_date (str): The date to end the analysis and open the position. Format: %Y-%m-%d.\n        end_date (str): The date to close the position. Format: %Y-%m-%d.\n    \"\"\"\n    # Parse Datetime Strings\n    self.start_date = datetime.strptime(start_date, \"%Y-%m-%d\")\n    self.midpoint_date = datetime.strptime(midpoint_date, \"%Y-%m-%d\")\n    self.end_date = datetime.strptime(end_date, \"%Y-%m-%d\")\n</code></pre>"},{"location":"sector/#sector.sector.Sector.test_best_worst","title":"<code>test_best_worst()</code>","text":"<p>Calculate the performance of the SHORT and LONG positions, for the best and worst stocks in a sector, respectively.</p> Source code in <code>sector\\sector.py</code> <pre><code>def test_best_worst(self):\n    \"\"\"Calculate the performance of the SHORT and LONG positions,\n    for the best and worst stocks in a sector, respectively.\n    \"\"\"\n    best_df = self.best_stock_df.loc[self.midpoint_date : self.end_date]\n    worst_df = self.worst_stock_df.loc[self.midpoint_date : self.end_date]\n\n    self.short_performance = calculate_position(best_df, PositionType.SHORT)\n    self.long_performance = calculate_position(worst_df, PositionType.LONG)\n</code></pre>"},{"location":"testbench/","title":"TestBench","text":""},{"location":"testbench/#testbench.portfolio.Portfolio","title":"<code>Portfolio</code>","text":"Source code in <code>testbench\\portfolio.py</code> <pre><code>class Portfolio:\n    balance = 0\n    start_date: datetime\n    backtest_interval: str\n    test_interval: str\n    end_date: datetime\n\n    def __init__(\n        self,\n        starting_balance: float,\n        start_date: datetime,\n        backtest_interval: str,\n        test_interval: str,\n        end_date: datetime,\n    ):\n        \"\"\"Constructor for the Portfolio class.\n\n        Args:\n            starting_balance: The balance to start the portfolio with.\n            start_date: The date to begin the portfolio at.\n            backtest_interval: The interval to look back to determine best and worst performing stocks (e.g., \"1m\" for 1 month, \"1d\" for 1 day, etc.).\n            test_interval: The interval to have the position open for.\n            end_date: The date to end the portfolio at.\n        \"\"\"\n\n        self.balance = starting_balance\n        self.start_date = start_date\n        self.backtest_interval = backtest_interval\n        self.test_interval = test_interval\n        self.end_date = end_date\n\n    def calculate_positions(\n        self,\n        capital: float,\n        best_stock: str,\n        worst_stock: str,\n        start_date: datetime,\n        end_date: datetime,\n    ) -&gt; pd.Series:\n        best_stock_df = Sector.load_stock(best_stock)\n        worst_stock_df = Sector.load_stock(worst_stock)\n\n        best_stock_df = best_stock_df.loc[start_date:end_date]\n        worst_stock_df = worst_stock_df.loc[start_date:end_date]\n\n        best_position = calculate_position_daily(\n            capital / 2, best_stock_df, PositionType.SHORT\n        )\n        worst_position = calculate_position_daily(\n            capital / 2, worst_stock_df, PositionType.LONG\n        )\n\n        return best_position + worst_position\n\n    def run_strategy(self, sectors: List[Sector], random_stocks=False) -&gt; pd.Series:\n        backtest_timeframe_delta = parse_timeframe(self.backtest_interval)\n        test_timeframe_delta = parse_timeframe(self.test_interval)\n\n        utcnow = datetime.now()\n        time_delta = utcnow + test_timeframe_delta - utcnow\n\n        total_tests = (self.end_date - self.start_date) // time_delta\n\n        print(f\"Total Tests: {total_tests}\")\n\n        current_date = self.start_date\n\n        portfolio_value = pd.Series()\n\n        for i in range(total_tests):\n\n            backtest_start_date = current_date - backtest_timeframe_delta\n            backtest_end_date = current_date\n            test_start_date = current_date\n            test_end_date = current_date + test_timeframe_delta\n            current_date = test_end_date\n\n            sector_performance_series = pd.Series()\n\n            for sector in sectors:\n                sector.set_dates(\n                    backtest_start_date.strftime(\"%Y-%m-%d\"),\n                    backtest_end_date.strftime(\"%Y-%m-%d\"),\n                    test_end_date.strftime(\"%Y-%m-%d\"),\n                )\n                best_stock = \"\"\n                worst_stock = \"\"\n\n                while True:\n\n                    if not random_stocks:\n                        sector.calculate_best_worst()\n\n                        best_stock = sector.best_stock\n                        worst_stock = sector.worst_stock\n                    else:\n                        best_stock = random.choice(sector.sector_stocks)\n                        worst_stock = random.choice(sector.sector_stocks)\n\n                    capital = self.balance / len(sectors)\n                    try:\n                        positions = self.calculate_positions(\n                            capital,\n                            best_stock,\n                            worst_stock,\n                            test_start_date,\n                            test_end_date,\n                        )\n\n                        if sector_performance_series.empty:\n                            sector_performance_series = positions\n                        else:\n                            sector_performance_series += positions\n                        break\n                    except:\n                        pass\n\n            if portfolio_value.empty:\n                portfolio_value = sector_performance_series\n            else:\n                portfolio_value = pd.concat(\n                    [portfolio_value, sector_performance_series]\n                )\n            self.balance = float(portfolio_value.iloc[-1])\n\n            print(f\"Balance After Test {i+1}: {self.balance}\")\n            print(portfolio_value.tail(25))\n            portfolio_value.to_csv(\"port.csv\")\n\n        return portfolio_value\n\n    def run_custom_sectors(\n        self, sector_definitions: pd.DataFrame, random_stocks=False\n    ) -&gt; pd.Series:\n        backtest_timeframe_delta = parse_timeframe(self.backtest_interval)\n        test_timeframe_delta = parse_timeframe(self.test_interval)\n\n        utcnow = datetime.now()\n        time_delta = utcnow + test_timeframe_delta - utcnow\n\n        total_tests = (self.end_date - self.start_date) // time_delta\n\n        print(f\"Total Tests: {total_tests}\")\n\n        current_date = self.start_date\n\n        portfolio_value = pd.Series()\n\n        for i in range(total_tests):\n\n            backtest_start_date = current_date - backtest_timeframe_delta\n            backtest_end_date = current_date\n            test_start_date = current_date\n            test_end_date = current_date + test_timeframe_delta\n            current_date = test_end_date\n\n            sector_obj = {}\n\n            # sector_definition = sector_definitions.loc[backtest_start_date]\n\n            sector_definition = get_row_by_date(sector_definitions, backtest_start_date)\n\n            # for each column in the row\n            for column in sector_definition.index:\n                value = sector_definition[column]\n                if value not in sector_obj:\n                    sector_obj[value] = []\n\n                sector_obj[value].append(column)\n\n            sectors = [Sector(name, sector_obj[name]) for name in sector_obj.keys()]\n\n            sector_performance_series = pd.Series()\n\n            for sector in sectors:\n                sector.set_dates(\n                    backtest_start_date.strftime(\"%Y-%m-%d\"),\n                    backtest_end_date.strftime(\"%Y-%m-%d\"),\n                    test_end_date.strftime(\"%Y-%m-%d\"),\n                )\n                best_stock = \"\"\n                worst_stock = \"\"\n\n                while True:\n\n                    if not random_stocks:\n                        sector.calculate_best_worst()\n\n                        best_stock = sector.best_stock\n                        worst_stock = sector.worst_stock\n                    else:\n                        best_stock = random.choice(sector.sector_stocks)\n                        worst_stock = random.choice(sector.sector_stocks)\n\n                    capital = self.balance / len(sectors)\n                    try:\n                        positions = self.calculate_positions(\n                            capital,\n                            best_stock,\n                            worst_stock,\n                            test_start_date,\n                            test_end_date,\n                        )\n\n                        if sector_performance_series.empty:\n                            sector_performance_series = positions\n                        else:\n                            sector_performance_series += positions\n                        break\n                    except:\n                        pass\n\n            if portfolio_value.empty:\n                portfolio_value = sector_performance_series\n            else:\n                portfolio_value = pd.concat(\n                    [portfolio_value, sector_performance_series]\n                )\n            self.balance = float(portfolio_value.iloc[-1])\n\n            print(f\"Balance After Test {i+1}: {self.balance}\")\n            print(portfolio_value.tail(25))\n            portfolio_value.to_csv(\"port2.csv\")\n</code></pre>"},{"location":"testbench/#testbench.portfolio.Portfolio.__init__","title":"<code>__init__(starting_balance, start_date, backtest_interval, test_interval, end_date)</code>","text":"<p>Constructor for the Portfolio class.</p> <p>Parameters:</p> Name Type Description Default <code>starting_balance</code> <code>float</code> <p>The balance to start the portfolio with.</p> required <code>start_date</code> <code>datetime</code> <p>The date to begin the portfolio at.</p> required <code>backtest_interval</code> <code>str</code> <p>The interval to look back to determine best and worst performing stocks (e.g., \"1m\" for 1 month, \"1d\" for 1 day, etc.).</p> required <code>test_interval</code> <code>str</code> <p>The interval to have the position open for.</p> required <code>end_date</code> <code>datetime</code> <p>The date to end the portfolio at.</p> required Source code in <code>testbench\\portfolio.py</code> <pre><code>def __init__(\n    self,\n    starting_balance: float,\n    start_date: datetime,\n    backtest_interval: str,\n    test_interval: str,\n    end_date: datetime,\n):\n    \"\"\"Constructor for the Portfolio class.\n\n    Args:\n        starting_balance: The balance to start the portfolio with.\n        start_date: The date to begin the portfolio at.\n        backtest_interval: The interval to look back to determine best and worst performing stocks (e.g., \"1m\" for 1 month, \"1d\" for 1 day, etc.).\n        test_interval: The interval to have the position open for.\n        end_date: The date to end the portfolio at.\n    \"\"\"\n\n    self.balance = starting_balance\n    self.start_date = start_date\n    self.backtest_interval = backtest_interval\n    self.test_interval = test_interval\n    self.end_date = end_date\n</code></pre>"}]}